---
title: Operating System Concepts Notes
tags:
  - Operating System
  - Process
  - Thread
  - Virtual-Memory
categories:
  - Learning Notes
mathjax: false
date: 2019-04-20 15:16:05
---

操作系統筆記
搭配恐龍舒服用
<!--more-->


# Ch1.
![](https://i.imgur.com/3fhqllG.png)

Q1. What is the purpose of interrupt
A1. An interrupt can be used to signal the completion of an I/O to obviate the need for device polling
Q2. Trap vs Interrupt
A2. Interrupt is hardware-generated, Trap is software-generated. Trap can be call by user program, used to call opearating system routines or to catch arithmetic errors.

# Ch2.

Q1. Long term vs Short term
A1.
Long-Term Scheduler - selects which processes should be brought into the ready queue, invoked , and controls the degree of multiprogramming.
Short-Term Scheduler - selects which processes should be executed next and allocates CPU, invoked frequently.


# Part2 Process Management

# Ch3 Process
![](https://i.imgur.com/UtYZ7vA.png)

## Process and Thread

**Zombie process**
當一個子進程結束後, 但他仍然在進程表中. 一般這需要父進程來讀取` exit `狀態, 要是一直沒有將殭屍進程釋放(reaped), 就會導致資源耗竭
所以其實每個 children process 都會變成 zombie process
**Orphan process**
這是父進程結束但子進程卻還在跑的進程, 這些會被`init`(pid=1)收養

**Thread vs Process**
Threads run in shared memory space, while processes run in seperate memory space



# Ch5. Process Synchronization

Mutex vs. Semaphore 差別?
[Difference between binary semaphore and mutex](https://stackoverflow.com/questions/62814/difference-between-binary-semaphore-and-mutex)
看完還是覺得這兩個很像阿 ...

Mutex boolean variables
Semaphore interger variables
Monitor = mutex + conditional variables

Peterson’s Solution
```
P0: flag[0] = true;
    turn = 1;
    while (flag[1] == true && turn == 1)
    {
        // busy wait
    }
    // critical section
    ...
    // end of critical section
    flag[0] = false;
P1: flag[1] = true;
    turn = 0;
    while (flag[0] == true && turn == 0)
    {
        // busy wait
    }
    // critical section
    ...
    // end of critical section
    flag[1] = false;
```

# Ch6 CPU Scheduling

Dispatch Latency time its takes for the dispatcher to stop a process and start another running


# Ch7 Dead Lock
Dead Lock 4個必須
1. Mutual Exclusion
2. Hold and wait
3. No preemption
4. Circular Wait

解決方法:
DeadLock Prevention
避免上述4個條件發生
(1) 有些資源本身有互斥 無解
(2) 讓process(1)拿全部(2)都不拿(3)可以拿部分,但如果要更多就要先丟掉手上的再申請資源
(3) 讓他可以搶資源 可惜有些設備不可搶資源
(4) 給他們編號 排隊拿資源
DeadLock Avoidance
Banker ALgorithm
系統分成 unsafe和safe
unsafe可能發生deadlock的情況
safe是保證安全的
如果當前系統是safe的就允許拿資源 否則拒絕

![](https://i.imgur.com/Nz1LsK9.png)

# Part3 Memory Management

## Ch8 Main Memory

![](https://i.imgur.com/aZtV4to.png)
Address Binding
(i)compile time 會產生absolute code, 若起始位置變更則重新compile	
(ii) load time 如果compile時無法確定位置則生成relocatable code


Paging vs Segment
![](https://i.imgur.com/hrP9iTi.png)

External Segmentation vs Internal Segmentation
External Segmentation: 隨著 process 不斷的移入移出, block的記憶體會被分成許多碎片 因為他們不連續所以無法滿足process的要求

First fit - 找到第一個可行的 普遍最快
Best fit - 需要搜尋所有list 最小可行解 但cost比較高 或者需要DS來處理排序問題 都沒有First bit好
Worsr fit - 一樣找全部最大的可行解 都沒有上面兩種好


## Q&A
Q1.
logical vs physical addresses
A1. 
logical address is generated by CPU and is translated into physical address by MMU
physical address is generated by MMU

Q2.
Page Table size 太大 解決方法
A2.
n-level, hash, inverted




# Ch.9 Virtual Memory

Pros:
To keep many processes in memory simultaneously to allow multiprogramming
Programs can be larger than physical memory
不用考慮memory-storage limitaions
shared files easily, shared memory
efficient for process creation
Cons:

Thrashing
如果 process 沒有足夠的 frame
他處理 page fault 的次數會增加
cpu效能會劇減

定義: 花在 paging 時間超過 execution
解決方法:
1. 降低 multiprogramming degree
2. Page Fault Frequency
3. Working Set Model

Copy on Write
Child process fork() 如果馬上 exec() 這樣複製給child process的address space就很浪費了
一開始就給parent和child共用一個pages

## Q&A
Q1. 什麼時候會產生 page faults
A1. 當 access page 的時候, 沒辦法在 main memory 找到

Q2. 題目如下
```
a. for(int i=0;i<100;i++)
	for(int j=0;j<100;j++)
		a[i][j]=0;
b. for(int j=0;j<100;j++)
	for(int i=0;i<100;i++)
		a[i][j]=0;	
```
a[0][0] is at location 200

A2.
a. 一開始是 columns change, size 200 所以 i 跑2個才會發生一次 page fault
100 / 2  = 50
b. 一開始 row change 所以 row 跑2個 其實就跑過 200 size 得到1次 page fault
(100 / 2) * 100(j的部分) = 5000

Q3.
最少所需frame
ADD A,B,C Direct
ADD (A),(B),(C) Indirect
A3.
ADD A,B,C = 1(instrucion本身) + (1 + 1 + 1) Direct
ADD (A), (B), (C) = 1(instrucion本身) + (2 + 2 + 2) Indirect

Q4.
Given an x86-64 computer system with a 48-bit virtual address, let the
system be only byte-addressable. Assume that every page is of 2KB with
8 bytes per page entry in the page table. Suppose that the frame number
needs 7 bytes to store. Please answer the following questions: (21pts).
a. What would be the maximum number of pages owned by a process? What is
   the number of frames owned by a process? (6pts)
b. Suppose that we have multi-level paging. How many levels do we have in
   multi-level paging? (5pts)
c. Suppose that TLB is adopted for paging, where the above multi-level
   paging is used. Let the memory access time and TLB access time be 100ns
   and 10ns, respectively. When the TLB hit ratio is 99%, what is the
   effective memory access time? (5pts)
d. Suppose that demand paging is adopted. Let p be the probability of a
   page fault, and ma be set as 110ns for the memory access time. pft is
   the page fault time. When pft is 10ms, what is the probability of a
   page fault so that the effective access time will not be over 120ns.
   Note that 1ms = 10^(-3)s, 1ns = 10^(-9)s. (5pts)
A4.
(a)
2^48/2^11 = 2^37 pages, 2^37 frames
(b)
48bit, pagesize = 2KB = 2^11
page entry 8 bytes, 2^11/2^3 = 2^8 entries 一個level最多用8個bit
2^48/2^11(offest) = 2^37
37/8 =4.xx =5
8 8 7 7 7 = 37
所以5-level
(c)
EMAT = TLB hit ratio * (TLB hit time + memory access time) + TLB miss ratio * (TLB hit time + memory access time * 2)
0.99 * (100+10ns) + 0.01 * (100+0.1*2)
(d)
effective access time = (1 − p) × ma + p × page fault time
120 >= (1-p) * 110 + p * 10*10^6
120 - 110 >= p * (- 110 + 10^7)
p <= 10 / (- 110 + 10^7), p = 1 / (10^6 - 11)

Q5.
Given a computer system with a 52-bit virtual address, let the physical
address be of 64-bit, and the system is only word-addressable, and every
word is of 8 bytes. Assume that evrey page is of 8 KB with 8 bytes per page
entry in the page table. Please answer the following questions : (23pts)
	a. What would be the maximum number of frames owned by a process? What
	   is the maximum logical address space for a process in terms of
	   bytes? (10pts)
	b. Suppose that TLB is adopted for paging, and there is only one level
	   for paging. Let the memory access time and TLB access time be 100ns
	   and 10ns, respectively. When the TLB hit ratio is 98%, what is the
	   effective memory access time? (5pts)
	c. Suppose that we have multi-level paging. How many levels do we have
	   in multi-level paging? What is the effective memory access time now
	   (continued from the above subproblem)? (8pts)
A5.
`Each bit in the 32-bit address space represents 1 byte in a byte-addressable system.`
我猜 word-addressable 就是 1-bit 1 word

(a)
a. 2^42 pages ; 2^52 * 2^3 bytes
(a) 我覺得題目要求的frame 應該是 2^64*2^3 / 2^13 = 2^54, 如果是要求pages 2^52*2^3 / 2^13 = 2^42
b. EMAT = 2% * 210  + 98% * 110  , unit = ns
c. 5 levels; EMAT = 2% * 610 + 98% * 110
(c) EMAT= p * (TLB-Access-time + Memory Access time) + (1-p) *[TLB-Access-time +(n+1 *Memory Access time)]

# Ch11. File System


# 名詞解釋
1. Starvation
一個process wait infinitely without receiving resoure
2. Paged Segmentation
divide segments into pages
3. Absolute Code (Hint : Binding Time)
It refers to a program, where the binding times is at the compile time.
4. Belady's Anomaly
increase number of page frames results in an increase in the number of page faults
FIFO是一個例子
5. Implicit Threading
Transfer the creation and management of the threading from the app developers to compilers and run-time lib.
6. Race Condtion
A situation where the outcome of the execution depends on the particular order of process scheduling
7. System call
OS interface to a running program.
An explicitly request to the kernel mode via software interrupt.



# 參考
[OS - Ch8 記憶體管理 Memory Management](https://mropengate.blogspot.com/2015/01/operating-system-ch8-memory-management.html)
[[試題] 103下 郭大維 作業系統 期末考+解答](https://www.ptt.cc/bbs/NTU-Exam/M.1437210714.A.B8A.html)
[Chapter 9 Virtual-Memory Management](https://www.csie.ntu.edu.tw/~ktw/uos/uos2005-Chp9.pdf)