---
title: 矩陣快速冪
tags:
  - 矩陣快速冪
categories:
  - ACM
mathjax: true
date: 2018-12-13 18:22:42
---

PTC-2018-12-A
矩陣快速冪
<!--more-->

f[0]=f[1]=f[2]=1
f[i]=f[i-1]+f[i-3] ,i>=3

用矩陣快速冪處理

遞推式
$$
\begin{bmatrix}
f_n\\ 
f_{n-1}\\ 
f_{n-2}
\end{bmatrix}
=
\begin{bmatrix}
1 &0  &1 \\ 
1 &0  &0 \\ 
0 &1  &0
\end{bmatrix}
\begin{bmatrix}
f_{n-1}\\ 
f_{n-2}\\ 
f_{n-3}
\end{bmatrix}
$$

從初始求
$$
\begin{bmatrix}
f_n\\ 
f_{n-1}\\ 
f_{n-2}
\end{bmatrix}
=
\begin{bmatrix}
1 &0  &1 \\ 
1 &0  &0 \\ 
0 &1  &0
\end{bmatrix}^{n-2}
\begin{bmatrix}
f_{2}\\ 
f_{1}\\ 
f_{0}
\end{bmatrix}
$$
$$
f_2=f_1=f_0=1
$$

```cpp
#include <bits/stdc++.h>
#define Accel ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
#define LL long long
using namespace std;
const int N=1e3+10;
const int M=997;

struct Matrix{
	int mat[4][4];
	
	
}I,A,T;
Matrix Mat_mul(Matrix a,Matrix b){
	Matrix c;
	
	for(int i=1;i<=3;i++)
		for(int j=1;j<=3;j++){
			c.mat[i][j]=0;
			for(int k=1;k<=3;k++){
				c.mat[i][j]+=a.mat[i][k]*b.mat[k][j];
				c.mat[i][j]%=M;
			}
		}
	return c;
}
Matrix Mat_pow(int b){
	Matrix a=A,t=I;
	while(b>=1){
		if(b&1){
			t=Mat_mul(t,a);
		}
		b>>=1;
		a=Mat_mul(a,a);
	}
	return t;
}
int n;
int main(){
	int t;
	cin>>t;
	while(t--){
		cin>>n;
		memset(I.mat,0,sizeof(I.mat));
		memset(A.mat,0,sizeof(A.mat));
		for(int i=1;i<=3;i++)
			I.mat[i][i]=1;
		A.mat[1][1]=A.mat[1][3]=A.mat[2][1]=A.mat[3][2]=1;
		T=Mat_pow(n-2);
		cout<<(T.mat[1][1]+T.mat[1][2]+T.mat[1][3])%M<<endl;
	}
	
}
```